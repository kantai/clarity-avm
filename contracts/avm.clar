
;; AVM state
;; version 1 uses 128 bit math :o
(define-constant AVM_STATE_HALTED u0)
(define-constant AVM_STATE_ERROR_STOP u1)
(define-constant AVM_STATE_EXTENSIVE u2)
(define-data-var avm-state uint AVM_STATE_HALTED)

(define-data-var cur-codepoint { op: (buff 1), nextHash: uint } { op: 0x00, nextHash: u0 })
(define-map data-stack uint (buff 1024))
;; points to the _next_ filled spot, i.e., data-stack[tail] is empty
(define-data-var data-stack-tail uint u0)
(define-map aux-stack uint (buff 1024))
;; points to the _next_ filled spot, i.e., data-stack[tail] is empty
(define-data-var aux-stack-tail uint u0)
(define-data-var register (buff 1024) 0x00)
(define-constant static 0x00)
(define-data-var avm-gas-remaining uint u0)
(define-data-var error-codepoint { op: (buff 1), nextHash: uint } { op: 0x00, nextHash: u0 })

(define-private (raise-error-ebuff)
    0x00 ;; todo, actually error out.
)

(define-private (deser-int (x (buff 1024)))
    (ok (unwrap! (from-consensus-buff uint x) (err u2))))

(define-private (deser-codepoint (x (buff 1024)))
    (ok (unwrap! (from-consensus-buff { op: (buff 1), nextHash: uint } x) (err u2))))

(define-private (pop-data-stack)
  (let ((tail (var-get data-stack-tail)))
    (asserts! (< u0 tail) (err u0))
    (var-set data-stack-tail (- u1 tail))
    (let ((rval (unwrap! (map-get? data-stack (- u1 tail)) (err u1))))
        (map-delete data-stack (- u1 tail))
        (ok rval))))
(define-private (pop-aux-stack)
  (let ((tail (var-get aux-stack-tail)))
    (asserts! (< u0 tail) (err u0))
    (var-set aux-stack-tail (- u1 tail))
    (let ((rval (unwrap! (map-get? aux-stack (- u1 tail)) (err u1))))
        (map-delete aux-stack (- u1 tail))
        (ok rval))))

(define-private (push-data-stack (x (buff 1024)))
  (let ((tail (var-get data-stack-tail)))
    (var-set data-stack-tail (+ u1 tail))
    (ok (map-set data-stack tail x))))
(define-private (push-data-stack-int (x uint))
    (push-data-stack (unwrap! (to-consensus-buff x) (err u500))))
(define-private (push-aux-stack (x (buff 1024)))
  (let ((tail (var-get aux-stack-tail)))
    (var-set aux-stack-tail (+ u1 tail))
    (map-set aux-stack tail x)))

(define-private (step-add)
  (let ((a_val (try! (pop-data-stack)))
        (b_val (try! (pop-data-stack)))
        (a_int (try! (deser-int a_val)))
        (b_int (try! (deser-int b_val))))
    (push-data-stack-int (+ a_int b_int))))

(define-private (step-pop)
  (begin
    (try! (pop-data-stack))
    (ok true)))
(define-private (step-spush)
  (push-data-stack static))
(define-private (step-rpush)
  (push-data-stack (var-get register)))
(define-private (step-rset)
  (ok (var-set register (try! (pop-data-stack)))))
(define-private (step-jump)
  (ok (var-set cur-codepoint (try! (deser-codepoint (try! (pop-data-stack)))))))
(define-private (step-cjump)
  (let ((a_val (try! (pop-data-stack)))
        (b_val (try! (pop-data-stack)))
        (a_cp (try! (deser-codepoint a_val)))
        (b_int (try! (deser-int b_val))))
        (if (is-eq b_int u0) 
            (ok true)
            (ok (var-set cur-codepoint a_cp)))))
(define-private (step-stackempty)
  (if (is-eq u0 (var-get data-stack-tail))
      (push-data-stack-int u1)
      (push-data-stack-int u0)))
(define-private (step-pcpush)
  (push-data-stack (unwrap! (to-consensus-buff (var-get cur-codepoint)) (err u500))))
(define-private (step-auxpush)
  (ok (push-aux-stack (try! (pop-data-stack)))))
(define-private (step-auxpop)
  (push-data-stack (try! (pop-aux-stack))))
(define-private (step-auxstackempty)
  (if (is-eq u0 (var-get aux-stack-tail))
      (push-data-stack-int u1)
      (push-data-stack-int u0)))
(define-private (step-nop) (ok true))
(define-private (step-errpush)
  (push-data-stack (unwrap! (to-consensus-buff (var-get error-codepoint)) (err u500))))
(define-private (step-errset)
    (ok (var-set error-codepoint
     (try! (deser-codepoint (try! (pop-data-stack)))))))

;; handler for arithmetic opcodes. if passed an op that isn't in the range, return none
(define-private (step-arithmetic (op (buff 1)))
  (if (is-eq op 0x01) (some (step-add))
       none))

;; handler for flow control opcodes. if passed an op that isn't in the range, return none
(define-private (step-flow (op (buff 1)))
  (if (is-eq op 0x30) (some (step-pop))
  (if (is-eq op 0x31) (some (step-spush))
  (if (is-eq op 0x32) (some (step-rpush))
  (if (is-eq op 0x33) (some (step-rset))
  (if (is-eq op 0x34) (some (step-jump))
  (if (is-eq op 0x35) (some (step-cjump))
  (if (is-eq op 0x36) (some (step-stackempty))
  (if (is-eq op 0x37) (some (step-pcpush))
  (if (is-eq op 0x38) (some (step-auxpush))
  (if (is-eq op 0x39) (some (step-auxpop))
  (if (is-eq op 0x3a) (some (step-auxstackempty))
  (if (is-eq op 0x3b) (some (step-nop))
  (if (is-eq op 0x3c) (some (step-errpush))
  (if (is-eq op 0x3d) (some (step-errset))
  none)))))))))))))))

(define-private (step)
    (let ((op (get op (var-get cur-codepoint))))
        (match (step-arithmetic op) result result
        (match (step-flow op) result result        
        (err u404)))))
